<<<<<<< HEAD
[{"content":"Introduction Today will introduce Java\u0026rsquo;s OOP, inclue class, attribute, construtor, method\n今天将介绍Java的面向对象学习的三条主线\nContent 4. 面向对象 Java 类及类的成员： 属性，方法，构造器，代码块，内部类。 面向对象的三大特征： 封装性，继承性，多态性。 其他关键字：this、super、static、final、 abstract、interface、package、import 等。 4.1 面向过程(POP) 与面向对象(OOP) 面向过程： Procedure Oriented Programming 强调的是功能行为，以函数为最小单位，考虑怎么做。\n面向对象： Object Oriented Programming 强调具备了功能的对象，以类/ 对象为最小单位，考虑谁来做。\n4.2 类和对象 类：对一类事物的描述，是抽象的，概念上的定义。 对象：是实际存在的该类事物的每个个体， 因而也称为实例（instance）。\n面向对象程序设计的重点是类的设计。\n设计类，就是设计类的成员。 属性 == 成员变量 == field == 域、字段 方法 == 成员方法 == 函数 == method 创建类的对象 == 类的实例化 == 实例化类 4.2.1 类的成员之一：属性 成员变量 VS 局部变量 相同点 ① 定义变量的格式：数据类型 变量名 = 变量值；\n② 先声明，后使用；\n③ 变量都有其对应的作用域。\n不同点 ① 在类中声明的位置不同：\n属性：直接定义在类的一对{} 内；\n局部变量：声明在方法内、方法形参、代码块内、构造器内部的变量。\n② 关于权限修饰符的不同：\n属性：可以在声明属性是，指明其权限，使用权限修饰符。\n常用的权限修饰符：private、public、缺省、protected\n局部变量：不可以使用权限修饰符。\n④ 在内存加载中的位置：\n属性：加载到堆空间中（非static）；\n局部变量：加载到栈空间中。\n4.2.2 类的成员之二：方法 方法：描述类应该具有的功能 比如：Math 类：sqrt() / random() / \u0026hellip;\nScanner 类：nextXxx() \u0026hellip;\nArrays 类：sort() / binarysearch() \u0026hellip;\ntostring() / equals() / \u0026hellip;\n举例 public void eat(){} public void sleep(int hour){} public String getName(){} public String getNation(String netion){}\n方法的声明：权限修饰符、返回值类型、方法名（形参列表）{\n方法体\n}\npublic class Person { String name; int age; boolean isMate; public void eat(){ System.out.println(\u0026quot;people eat food\u0026quot;); } public void sleep(){ System.out.println(\u0026quot;people can sleep\u0026quot;); } public void talk(String language){ System.out.println(\u0026quot;People can talk the:\u0026quot;+language); } public void printIfSex(boolean isMate){ if(isMate==true){ System.out.println(\u0026quot;My name is:\u0026quot; + name + \u0026quot;\\nMy age is:\u0026quot; +age +\u0026quot;\\n\u0026quot;); } } } 4.2.3 类的成员之三：构造器（构造方法、constructor） 构造器的作用: 创建对象\n初始化对象的属性 二、说明\n如果没有显示的定义类的构造器的话，则系统默认 提供一个空参的构造器。\n定义构造器的格式: 权限修饰符 类名( 形参列表) { }\n一个类中定义的多个构造器，彼此构成重载。\n一旦显示的定义了类的构造器之后，系统不再提供 默认的空参构造器。\n一个类中，至少会有一个构造器。\nclass Person{ // 属性 String name; int age; // 构造器 public Person(){ System.out.println(\u0026quot;Person()......\u0026quot;); } public Person(String n){ name = n; } public Person(String n,int a){ name = n; age = a; } // 方法 public void eat(){ System.out.println(\u0026quot; 人吃饭\u0026quot;); } public void study(){ System.out.println(\u0026quot; 人学习\u0026quot;); } } 4.2.4 关键字：this this 用来修饰、调用：属性、方法、构造器 this 修饰属性和方法: this 理解为：当前对象, 或当前正在创建的对象。\n在类的方法中，我们可以使用\u0026quot;this. 属性\u0026quot; 或\u0026quot;this. 方法\u0026quot; 的方式，调用当前对象属性或方法。\n4.3 对象的创建和使用：内存解析 堆（Heap）：此内存区域的唯一目的就是存放对象实例 栈（Stack）：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放 方法区（MethodArea）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 ","permalink":"https://jackywang96.github.io/BlogSite/post/java/java-lesson3/","summary":"Introduction Today will introduce Java\u0026rsquo;s OOP, inclue class, attribute, construtor, method\n今天将介绍Java的面向对象学习的三条主线\nContent 4. 面向对象 Java 类及类的成员： 属性，方法，构造器，代码块，内部类。 面向对象的三大特征： 封装性，继承性，多态性。 其他关键字：this、super、static、final、 abstract、interface、package、import 等。 4.1 面向过程(POP) 与面向对象(OOP) 面向过程： Procedure Oriented Programming 强调的是功能行为，以函数为最小单位，考虑怎么做。\n面向对象： Object Oriented Programming 强调具备了功能的对象，以类/ 对象为最小单位，考虑谁来做。\n4.2 类和对象 类：对一类事物的描述，是抽象的，概念上的定义。 对象：是实际存在的该类事物的每个个体， 因而也称为实例（instance）。\n面向对象程序设计的重点是类的设计。\n设计类，就是设计类的成员。 属性 == 成员变量 == field == 域、字段 方法 == 成员方法 == 函数 == method 创建类的对象 == 类的实例化 == 实例化类 4.2.1 类的成员之一：属性 成员变量 VS 局部变量 相同点 ① 定义变量的格式：数据类型 变量名 = 变量值；","title":"Java Lesson3 Note"},{"content":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 3. 数 组 数组(Array)，是多个相同类型数据按一定顺序排列的集合， 并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组里的相关概念\nArray name Elements Index length 3.1 一维数组的使用 用以下的方式熟悉一维数组\n一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 3.2 多维数组的使用 对于二维数组的理解，我们可以看成是一维数组array1 又作为另一个一维数组array2 的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。\npublic class ArrayTest2 { public static void main(String[] args) { //1. 二维数组的声明和初始化 int[] arr = new int[]{1,2,3}; // 静态初始化 int[][] arr1 = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][]; // String[][] arr5 = new String[][4]; // String[][] arr6 = new String[4][3]{{1,2,3},{4,5,6},{7,8,9}}; // 正确的情况： int arr4[][] = new int[][]{{1,2,3},{4,5,12,6},{7,8,9}}; int[] arr5[] = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; int[][] arr6 = {{1,2,3},{4,5,6},{7,8,9}}; //2. 如何调用数组的指定位置的元素 System.out.println(arr1[0][1]); //2 System.out.println(arr2[1][1]); //null //4. 如何遍历二维数组 for(int i = 0;i \u0026lt; arr4.length;i++){ for(int j = 0;j \u0026lt; arr4[i].length;j++){ System.out.print(arr4[i][ j] + \u0026quot; \u0026quot;); } System.out.println(); } } 3.2 Arrays 工具类的使用 java.util.Arrays 类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\npublic class ArrayTest4 { public static void main(String[] args) { //1.boolean equals(int[] a,int[] b) 判断两个数组是否相等。 int[] arr1 = new int[]{1,2,3,4}; int[] arr2 = new int[]{1,2,9,3}; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); //2.String toString(int[] a) 输出数组信息。 System.out.println(Arrays.toString(arr1)); //3.void fill(int[] a,int val) 将指定值填充到数组之中。 Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); //4.void sort(int[] a) 对数组进行排序。 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); //5.int binarySearch(int[] a,int key) 对排序后的数组进行二分 法检索指定的值。 int[] arr3 = new int[]{43,32,76,92,-65,85,71,-42}; int index = Arrays.binarySearch(arr3, 210); if(index \u0026gt;= 0){ System.out.println(index); }else{ System.err.println(\u0026quot; 未找到。\u0026quot;); } } }\n3.3 数组使用中的常见异常 数组角标越界的异常:ArrayIndexOutOfBoundsException\nfor(int i = 0;i \u0026lt;= arr.length;i++){ // System.out.println(arr[i]); // } 空指针异常:NullPointerException\nString[] arr3 = new String[]{\u0026quot;AA\u0026quot;,\u0026quot;QQ\u0026quot;,\u0026quot;YY\u0026quot;,\u0026quot;XX\u0026quot;,\u0026quot;TT\u0026quot;,\u0026quot;KK\u0026quot;}; // arr3[0] = null; // System.out.println(arr3[0].toString()); 3.4 数组中涉及到的常见算法 选择排序 直接选择排序、堆排序 交换排序 冒泡排序、快速排序 插入排序 直接插入排序、折半插入排序、Shell 排序 归并排序 桶式排序 基数排序 ","permalink":"https://jackywang96.github.io/BlogSite/post/java/java-lesson2/","summary":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 3. 数 组 数组(Array)，是多个相同类型数据按一定顺序排列的集合， 并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组里的相关概念\nArray name Elements Index length 3.1 一维数组的使用 用以下的方式熟悉一维数组\n一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 3.2 多维数组的使用 对于二维数组的理解，我们可以看成是一维数组array1 又作为另一个一维数组array2 的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。\npublic class ArrayTest2 { public static void main(String[] args) { //1. 二维数组的声明和初始化 int[] arr = new int[]{1,2,3}; // 静态初始化 int[][] arr1 = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][]; // String[][] arr5 = new String[][4]; // String[][] arr6 = new String[4][3]{{1,2,3},{4,5,6},{7,8,9}}; // 正确的情况： int arr4[][] = new int[][]{{1,2,3},{4,5,12,6},{7,8,9}}; int[] arr5[] = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; int[][] arr6 = {{1,2,3},{4,5,6},{7,8,9}}; //2.","title":"Java Lesson2 Note"},{"content":"Introduction 今天开始我将开始Java基础课程的教授。我会记录我每次备课的note并作为帖子发送至我的blog。\nContent 1. Java是什么样的语言 简单而言，使用JDK 的开发工具完成的java 程序，交给JRE 去运行\n- 面向对象: OOD（Object Oriented Programming）POP（Prodedure Oriented Programming）\n面向对象好在哪：POP小公司人少，所有安排事情是-你去干啥，他去干啥\nOOD: 大公司人多，分成多个部门，按职能分派任务\n三大特性：封装、继承、多态: 封装 用一个method隐藏赋值的过程、把属性变为private。只有外界用method去调用 public, private, default\n继承 inheritance； Child and parent class\n多态 overload\n- 健壮性: 吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如指针、 内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。\n- 跨平台性: 跨平台性：通过Java 语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 原理：只要在需要运行java 应用程序的操作系统上，先安装一个Java 虚拟机 (JVM Java Virtual Machine) 即可。由JVM 来负责Java 程序在该系统中的运行。\nJava 两种核心机制-Java VirtalMachine，Garbage Collection\n2. 基本语法 2.1 Java 中的名称命名规范 Package name: ：多单词组成时所有字母都小写：xxxyyyzzz Class、interface：所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ\n2.2 基本数据类型 变量按照数据类型来分： 基本数据类型：\n整型：byte \\ short \\ int \\ long\n浮点型：float \\ double\n字符型：char\n布尔型：boolean\n引用数据类型：\n类：class\n接口：interface\n数组：array\n2.3 字符串类型：String String 类型变量的使用：\nString 属于引用数据类型 。 声明String 类型变量时，使用一对\u0026quot;\u0026quot; 。 String 可以和8 种基本数据类型变量做运算， 且运算只能是连接运算；+ 运算的结果任然是String 类型。 2.4 强制类型转换 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出, 格外要注意。 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n如：String a = “43”;\ninti= Integer.parseInt(a);\nboolean 类型不可以转换为其它的数据类型。\n2.5 运算符 % 取余 7%5=2\n++ a=2; b=a++; a=2;b=3\n扩展赋值运算符：+=, -=, *=, /=, %=\n逻辑运算符\na||b a\u0026amp;\u0026amp;b\n2.6 顺序结构 public class Test{ int num1 = 12; int num2 = num1 + 2; } // 错误形式： public class Test{ int num2 = num1 + 2; int num1 = 12; } 2.7 判断语句 2.7.1、分支语句：if-else 结构 if(X\u0026gt;=0){ return result } else if(x\u0026lt;0\u0026gt;){ return 1; } else{ return 0; } 2.8. 循环结构 2.8.1 for 循环 // 遍历100 以内的偶数, 获取所有偶数的和, 输出偶数的个数 int sum=0; int count=0; for(int i=1; i\u0026lt;=100; i++){ if(i%2==0){ System.out.println(i); sum += i; count++ } } System.out.println(\u0026ldquo;100 以内的偶数的和：\u0026rdquo; + sum); System.out.println(\u0026quot; 个数为：\u0026quot; + count);\n2.8.2 while 循环 class WhileTest{ public static void main(String[] args){ // 遍历100 以内的所有偶数 int i = 1; while(i \u0026lt;= 100){ if(i % 2 == 0){ System.out.println(i); } i++; } } } 2.8.3 do-while 循环 int i = 0; do { System.out.println(i); i++; } while (i \u0026lt; 5); 2.9. break、continue 的使用 break 语句用于终止某个语句块的执行\n{ ...... break; ...... } continue 的使用 continue 语句：continue 只能使用在循环结构中。\ncontinue 语句用于跳过其所在循环语句块的一次执行，继续下一次 循环。\nreturn return：并非专门用于结束循环的，它的功能是结束一个方法。当一 个方法执行到一个return 语句时，这个方法将被结束。\n与break 和continue 不同的是，return 直接结束整个方法，不管这个 return 处于多少层循环之内。\n课后作业 目标\n需求说明\n基本金和收支明细的记录\n模拟实现一个基于文本界面的《家庭记账软件》。\n主要掌握以下知识点： 变量的定义， 基本数据类型的使用， 循环语句， 分支语句， 方法声明、调用和返回值的接收， 简单的屏幕输出格式控制 模拟实现基于文本界面的《家庭记账软件》。 该软件能够记录家庭收入、支出，并能够打印收支明细表。\n项目采用分级菜单方式。主菜单如下：\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 家庭收支记账软件\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n收支明细 登记收入 登记支出 退 出 请选择(1-4): ","permalink":"https://jackywang96.github.io/BlogSite/post/java/javal-lesson1/","summary":"Introduction 今天开始我将开始Java基础课程的教授。我会记录我每次备课的note并作为帖子发送至我的blog。\nContent 1. Java是什么样的语言 简单而言，使用JDK 的开发工具完成的java 程序，交给JRE 去运行\n- 面向对象: OOD（Object Oriented Programming）POP（Prodedure Oriented Programming）\n面向对象好在哪：POP小公司人少，所有安排事情是-你去干啥，他去干啥\nOOD: 大公司人多，分成多个部门，按职能分派任务\n三大特性：封装、继承、多态: 封装 用一个method隐藏赋值的过程、把属性变为private。只有外界用method去调用 public, private, default\n继承 inheritance； Child and parent class\n多态 overload\n- 健壮性: 吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如指针、 内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。\n- 跨平台性: 跨平台性：通过Java 语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 原理：只要在需要运行java 应用程序的操作系统上，先安装一个Java 虚拟机 (JVM Java Virtual Machine) 即可。由JVM 来负责Java 程序在该系统中的运行。\nJava 两种核心机制-Java VirtalMachine，Garbage Collection\n2. 基本语法 2.1 Java 中的名称命名规范 Package name: ：多单词组成时所有字母都小写：xxxyyyzzz Class、interface：所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ","title":"Java Lesson1 Note"},{"content":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Spark core module Spark Core: The most basic and core functions of Spark are provided in Spark Core\nSpark SQL: Spark SQL is the component that Spark uses to manipulate structured data. With Spark SQL, users can query data using SQL or the Apache Hive version of the SQL dialect (HQL).\nSpark Streaming: Spark Streaming is a component on the Spark platform that performs stream computing for real-time data, and provides a rich API for processing data streams.\n2. Spark running model Local model:\nAn environment that executes Spark code locally without requiring any other node resources Standalone model:\nSubmit the application to the corresponding cluster for execution, using the cluster mode running on Spark\u0026rsquo;s own nodes, which is what we call the standalone deployment (Standalone) mode.\nOnline monitor: Use the Master resource to monitor the Web UI interface: http://linux1:8080\nYarn model:\nThe Yarn mode can utilize the resources of the Hadoop cluster, and the Spark application is submitted to the YARN cluster. Provides functions such as dynamic resource allocation and job recovery, suitable for large-scale production environments.\nThe Standalone mode is more suitable for small-scale testing and development environments.\nK8S \u0026amp; Mesos model:\nMesos is an open source distributed resource management framework under Apache. It is known as the kernel of a distributed system. It is widely used in Twitter and manages the application deployment on more than 300,000 Twitter servers.\n","permalink":"https://jackywang96.github.io/BlogSite/post/big-data/spark-learning-2/","summary":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Spark core module Spark Core: The most basic and core functions of Spark are provided in Spark Core\nSpark SQL: Spark SQL is the component that Spark uses to manipulate structured data. With Spark SQL, users can query data using SQL or the Apache Hive version of the SQL dialect (HQL).\nSpark Streaming: Spark Streaming is a component on the Spark platform that performs stream computing for real-time data, and provides a rich API for processing data streams.","title":"Big Data Learning Day-2"},{"content":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Data processing tool Spark and Handoop Apache Spark: Apache Spark is an open-source, distributed computing system designed for big data processing and analytics. It offers support for various data processing tasks, including SQL queries, machine learning, and graph processing, through built-in libraries like Spark SQL, MLlib, and GraphX.\nApache Hadoop: Apache Hadoop is an open-source, distributed computing framework for processing and storing large amounts of data on clusters of commodity hardware. The core components of Hadoop are the Hadoop Distributed File System (HDFS) and the MapReduce programming model. HDFS is a distributed file system that provides high-throughput access to application data, while MapReduce is a parallel data processing model that simplifies large-scale data processing across distributed clusters.\n2. Data storage tool As big data involves large volumes of data, it requires specialized data storage systems such as HDFS, Amazon S3, or Google Cloud Storage.\n3. Data visualization and analysis Once the data has been processed, it needs to be analyzed and presented in a meaningful way. There are several tools available for data visualization and analysis, such as Tableau, Power BI, and Apache Superset.\n4. Data governance and security As big data involves sensitive data, it\u0026rsquo;s important to have strong data governance and security measures in place. This includes access control, data masking, and encryption.\n","permalink":"https://jackywang96.github.io/BlogSite/post/big-data/spark-learning-1/","summary":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Data processing tool Spark and Handoop Apache Spark: Apache Spark is an open-source, distributed computing system designed for big data processing and analytics. It offers support for various data processing tasks, including SQL queries, machine learning, and graph processing, through built-in libraries like Spark SQL, MLlib, and GraphX.\nApache Hadoop: Apache Hadoop is an open-source, distributed computing framework for processing and storing large amounts of data on clusters of commodity hardware.","title":"Big Data Learning Day-1"},{"content":"Introduction Tailwind CSS is a CSS styling library that provides us with all the building blocks we need to build custom designs without using custom styles.\nFeature Tailwind will automatically delete all unused CSS when building production files, so its size in the actual production environment is very small, and it is considered to be the CSS style library with the most design sense.\nInstallation //Install Tailwind CSS npm install -D tailwindcss npx tailwindcss init //Add the paths to all of your template files in your tailwind.config.js file. module.exports = { content: [\u0026#34;./src/**/*.{html,js}\u0026#34;], theme: { extend: {}, }, plugins: [], } //Add the Tailwind directives to your CSS @tailwind base; @tailwind components; @tailwind utilities; //Start the Tailwind CLI build process npx tailwindcss -i ./src/input.css -o ./dist/output.css --watch ","permalink":"https://jackywang96.github.io/BlogSite/post/tailwindcss/","summary":"Introduction Tailwind CSS is a CSS styling library that provides us with all the building blocks we need to build custom designs without using custom styles.\nFeature Tailwind will automatically delete all unused CSS when building production files, so its size in the actual production environment is very small, and it is considered to be the CSS style library with the most design sense.\nInstallation //Install Tailwind CSS npm install -D tailwindcss npx tailwindcss init //Add the paths to all of your template files in your tailwind.","title":"TailwindCSS"},{"content":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer. In this case, a third pointer is required at length of nums1. The role of the third pointer is to select where the larger number is placed\nSolution public class MergeSortedArray { public static void merge(int[]nums1, int m, int[]nums2, int n) { //有序数组条件下，设置3个指针，分别放在nums1，nums2和集合数组的末尾 int i=m-1; int j=n-1; int point= nums1.length-1; //判断nums2是否遍历完成 while(j\u0026gt;=0){ //如果nums2中元素小于nums1中的，则把nums1里的元素放到point指向的位置 //之后移动i和point指针 if(i\u0026gt;=0 \u0026amp;\u0026amp; nums1[i]\u0026gt;nums2[j]){ nums1[point]=nums1[i]; i--; point--; } //nums2的元素较大情况直接把nums2中最大元素放置到数组最右端。 //移动j和point指针 else{ nums1[point]=nums2[j]; point--; j--; } } } ","permalink":"https://jackywang96.github.io/BlogSite/post/fast-slow-pointer-floyd-circle-method/fast-slow-pointer/","summary":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer.","title":"Fast,Slow pointer--Floyd circle method"},{"content":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer. In this case, a third pointer is required at length of nums1. The role of the third pointer is to select where the larger number is placed\nSolution public class MergeSortedArray { public static void merge(int[]nums1, int m, int[]nums2, int n) { //有序数组条件下，设置3个指针，分别放在nums1，nums2和集合数组的末尾 int i=m-1; int j=n-1; int point= nums1.length-1; //判断nums2是否遍历完成 while(j\u0026gt;=0){ //如果nums2中元素小于nums1中的，则把nums1里的元素放到point指向的位置 //之后移动i和point指针 if(i\u0026gt;=0 \u0026amp;\u0026amp; nums1[i]\u0026gt;nums2[j]){ nums1[point]=nums1[i]; i--; point--; } //nums2的元素较大情况直接把nums2中最大元素放置到数组最右端。 //移动j和point指针 else{ nums1[point]=nums2[j]; point--; j--; } } } ","permalink":"https://jackywang96.github.io/BlogSite/post/merge-sorted-array/","summary":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer.","title":"Merge Sorted Array"},{"content":"SQL experience\nWhen combining tables, the efficiency of simply using the where statement is lower than join, which is equivalent to full join left join (left join): Returns all records including all records in the left table and records with equal join fields in the right table.\nright join (right join): Returns all records including all records in the right table and records with equal join fields in the left table.\nInner join (equivalent connection or inner connection): only returns the rows with the same connection fields in the two tables.\nfull join (full outer connection): Return all records in the left and right tables and records with the same connection fields in the left and right tables.\nThe way to use Null is Where xxxx is null\nUse limit 1, 1 to filter the second and third data that meet the conditions. eg. the second largest, the second highest\n","permalink":"https://jackywang96.github.io/BlogSite/post/sql/","summary":"SQL experience\nWhen combining tables, the efficiency of simply using the where statement is lower than join, which is equivalent to full join left join (left join): Returns all records including all records in the left table and records with equal join fields in the right table.\nright join (right join): Returns all records including all records in the right table and records with equal join fields in the left table.","title":"SQL"},{"content":"Hi, I\u0026rsquo;m Jack 👋 This is my first post. Welcome to my Blog\n","permalink":"https://jackywang96.github.io/BlogSite/post/my-first-post/","summary":"Hi, I\u0026rsquo;m Jack 👋 This is my first post. Welcome to my Blog","title":"My First Post"},{"content":"Hi, I\u0026rsquo;m Jack 👋 👤 Currently Software Development Engineer at Department of Education Victoria.\n📷 Enthusiastic in fitness, photography, travelling, reading \u0026amp; video games.\n📄 Checkout my resume: English / [简体中文]\n✉️ Contact me at JackyWangMel96@gmail.com\n","permalink":"https://jackywang96.github.io/BlogSite/about/","summary":"Hi, I\u0026rsquo;m Jack 👋 👤 Currently Software Development Engineer at Department of Education Victoria.\n📷 Enthusiastic in fitness, photography, travelling, reading \u0026amp; video games.\n📄 Checkout my resume: English / [简体中文]\n✉️ Contact me at JackyWangMel96@gmail.com","title":"About"}]
=======
[{"content":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。\n重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。\n说明\n1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参\n题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i \u0026lt; arr.length;i++){ arr[i] = arr[i] / arr[0]; }\n4.5 ：递归方法 递归方法：一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执 行无须循环控制。\n递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死 循环。\nexample //计算 1-100 之间所有自然数的和\npublic int sum(int num){ if(num == 1){ return 1; } else{ return num + sum(num 1); } } 4.6 ：面向对象 特征之一：封装和隐藏 为什么需要封装？封装的作用和含义？ -我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内 部的结构吗？有必要碰电动机吗？ 我们 程序设计追求 “高内聚，低耦合”。\n高内聚 ：类 的内部数据 操作细节自己完成，不允许外部干涉；\n低耦合 仅对外暴露 少量的 方法 用于 使用 。\n4.7 ：构造器重载 构造器一般用于创建对象的同时初始化对象 构造器的重载帮助创建对象更灵活。适合创建不同的对象 构造器重载，参数列表 必须 不同 4.8： 关键字 4.8.1： 关键字this 4.8.2： 关键字static 4.8.3： 关键字pacakge package 语句作为 Java 源文件的第一条语句，指明该文件中定义的类所在 的包。 若缺省该语句，则指定为无名包 。它的格式为： package 顶层包名.子包名\n举例 //pack1\\pack2\\PackageTest.java package pack1.pack2;\n包的作用\n包帮助管理大型软件 系统 将功能 相近的类划分到同一个包中 。 比如 MVC 的设计模式\n包可以包含类和 子包 划分项目 层次 便于管理\n控制访问权限\n4.8.4： 关键字import 为使用定义在不同包中的 Java 类，需用 import 语句来引入 指定包层次下 所需要的类 或全部类 。 import 语句告诉编译器到哪里去寻找类。\n","permalink":"https://jackywang96.github.io/BlogSite/post/java/javal-lesson4/","summary":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。\n重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。\n说明\n1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参\n题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i \u0026lt; arr.length;i++){ arr[i] = arr[i] / arr[0]; }","title":"Java Lesson4 Note"},{"content":"Introduction Today will introduce Java\u0026rsquo;s OOP, inclue class, attribute, construtor, method\n今天将介绍Java的面向对象学习的三条主线\nContent 4. 面向对象 Java 类及类的成员： 属性，方法，构造器，代码块，内部类。 面向对象的三大特征： 封装性，继承性，多态性。 其他关键字：this、super、static、final、 abstract、interface、package、import 等。 4.1 面向过程(POP) 与面向对象(OOP) 面向过程： Procedure Oriented Programming 强调的是功能行为，以函数为最小单位，考虑怎么做。\n面向对象： Object Oriented Programming 强调具备了功能的对象，以类/ 对象为最小单位，考虑谁来做。\n4.2 类和对象 类：对一类事物的描述，是抽象的，概念上的定义。 对象：是实际存在的该类事物的每个个体， 因而也称为实例（instance）。\n面向对象程序设计的重点是类的设计。\n设计类，就是设计类的成员。 属性 == 成员变量 == field == 域、字段 方法 == 成员方法 == 函数 == method 创建类的对象 == 类的实例化 == 实例化类 4.2.1 类的成员之一：属性 成员变量 VS 局部变量 相同点 ① 定义变量的格式：数据类型 变量名 = 变量值；\n② 先声明，后使用；\n③ 变量都有其对应的作用域。\n不同点 ① 在类中声明的位置不同：\n属性：直接定义在类的一对{} 内；\n局部变量：声明在方法内、方法形参、代码块内、构造器内部的变量。\n② 关于权限修饰符的不同：\n属性：可以在声明属性是，指明其权限，使用权限修饰符。\n常用的权限修饰符：private、public、缺省、protected\n局部变量：不可以使用权限修饰符。\n④ 在内存加载中的位置：\n属性：加载到堆空间中（非static）；\n局部变量：加载到栈空间中。\n4.2.2 类的成员之二：方法 方法：描述类应该具有的功能 比如：Math 类：sqrt() / random() / \u0026hellip;\nScanner 类：nextXxx() \u0026hellip;\nArrays 类：sort() / binarysearch() \u0026hellip;\ntostring() / equals() / \u0026hellip;\n举例 public void eat(){} public void sleep(int hour){} public String getName(){} public String getNation(String netion){}\n方法的声明：权限修饰符、返回值类型、方法名（形参列表）{\n方法体\n}\npublic class Person { String name; int age; boolean isMate; public void eat(){ System.out.println(\u0026quot;people eat food\u0026quot;); } public void sleep(){ System.out.println(\u0026quot;people can sleep\u0026quot;); } public void talk(String language){ System.out.println(\u0026quot;People can talk the:\u0026quot;+language); } public void printIfSex(boolean isMate){ if(isMate==true){ System.out.println(\u0026quot;My name is:\u0026quot; + name + \u0026quot;\\nMy age is:\u0026quot; +age +\u0026quot;\\n\u0026quot;); } } } 4.2.3 类的成员之三：构造器（构造方法、constructor） 构造器的作用: 创建对象\n初始化对象的属性 二、说明\n如果没有显示的定义类的构造器的话，则系统默认 提供一个空参的构造器。\n定义构造器的格式: 权限修饰符 类名( 形参列表) { }\n一个类中定义的多个构造器，彼此构成重载。\n一旦显示的定义了类的构造器之后，系统不再提供 默认的空参构造器。\n一个类中，至少会有一个构造器。\nclass Person{ // 属性 String name; int age; // 构造器 public Person(){ System.out.println(\u0026quot;Person()......\u0026quot;); } public Person(String n){ name = n; } public Person(String n,int a){ name = n; age = a; } // 方法 public void eat(){ System.out.println(\u0026quot; 人吃饭\u0026quot;); } public void study(){ System.out.println(\u0026quot; 人学习\u0026quot;); } } 4.2.4 关键字：this this 用来修饰、调用：属性、方法、构造器 this 修饰属性和方法: this 理解为：当前对象, 或当前正在创建的对象。\n在类的方法中，我们可以使用\u0026quot;this. 属性\u0026quot; 或\u0026quot;this. 方法\u0026quot; 的方式，调用当前对象属性或方法。\n4.3 对象的创建和使用：内存解析 堆（Heap）：此内存区域的唯一目的就是存放对象实例 栈（Stack）：是指虚拟机栈。虚拟机栈用于存储局部变量等。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址）。方法执行完，自动释放 方法区（MethodArea）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 ","permalink":"https://jackywang96.github.io/BlogSite/post/java/java-lesson3/","summary":"Introduction Today will introduce Java\u0026rsquo;s OOP, inclue class, attribute, construtor, method\n今天将介绍Java的面向对象学习的三条主线\nContent 4. 面向对象 Java 类及类的成员： 属性，方法，构造器，代码块，内部类。 面向对象的三大特征： 封装性，继承性，多态性。 其他关键字：this、super、static、final、 abstract、interface、package、import 等。 4.1 面向过程(POP) 与面向对象(OOP) 面向过程： Procedure Oriented Programming 强调的是功能行为，以函数为最小单位，考虑怎么做。\n面向对象： Object Oriented Programming 强调具备了功能的对象，以类/ 对象为最小单位，考虑谁来做。\n4.2 类和对象 类：对一类事物的描述，是抽象的，概念上的定义。 对象：是实际存在的该类事物的每个个体， 因而也称为实例（instance）。\n面向对象程序设计的重点是类的设计。\n设计类，就是设计类的成员。 属性 == 成员变量 == field == 域、字段 方法 == 成员方法 == 函数 == method 创建类的对象 == 类的实例化 == 实例化类 4.2.1 类的成员之一：属性 成员变量 VS 局部变量 相同点 ① 定义变量的格式：数据类型 变量名 = 变量值；","title":"Java Lesson3 Note"},{"content":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 3. 数 组 数组(Array)，是多个相同类型数据按一定顺序排列的集合， 并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组里的相关概念\nArray name Elements Index length 3.1 一维数组的使用 用以下的方式熟悉一维数组\n一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 3.2 多维数组的使用 对于二维数组的理解，我们可以看成是一维数组array1 又作为另一个一维数组array2 的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。\npublic class ArrayTest2 { public static void main(String[] args) { //1. 二维数组的声明和初始化 int[] arr = new int[]{1,2,3}; // 静态初始化 int[][] arr1 = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][]; // String[][] arr5 = new String[][4]; // String[][] arr6 = new String[4][3]{{1,2,3},{4,5,6},{7,8,9}}; // 正确的情况： int arr4[][] = new int[][]{{1,2,3},{4,5,12,6},{7,8,9}}; int[] arr5[] = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; int[][] arr6 = {{1,2,3},{4,5,6},{7,8,9}}; //2. 如何调用数组的指定位置的元素 System.out.println(arr1[0][1]); //2 System.out.println(arr2[1][1]); //null //4. 如何遍历二维数组 for(int i = 0;i \u0026lt; arr4.length;i++){ for(int j = 0;j \u0026lt; arr4[i].length;j++){ System.out.print(arr4[i][ j] + \u0026quot; \u0026quot;); } System.out.println(); } } 3.2 Arrays 工具类的使用 java.util.Arrays 类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。\npublic class ArrayTest4 { public static void main(String[] args) { //1.boolean equals(int[] a,int[] b) 判断两个数组是否相等。 int[] arr1 = new int[]{1,2,3,4}; int[] arr2 = new int[]{1,2,9,3}; boolean isEquals = Arrays.equals(arr1, arr2); System.out.println(isEquals); //2.String toString(int[] a) 输出数组信息。 System.out.println(Arrays.toString(arr1)); //3.void fill(int[] a,int val) 将指定值填充到数组之中。 Arrays.fill(arr1, 10); System.out.println(Arrays.toString(arr1)); //4.void sort(int[] a) 对数组进行排序。 Arrays.sort(arr2); System.out.println(Arrays.toString(arr2)); //5.int binarySearch(int[] a,int key) 对排序后的数组进行二分 法检索指定的值。 int[] arr3 = new int[]{43,32,76,92,-65,85,71,-42}; int index = Arrays.binarySearch(arr3, 210); if(index \u0026gt;= 0){ System.out.println(index); }else{ System.err.println(\u0026quot; 未找到。\u0026quot;); } } }\n3.3 数组使用中的常见异常 数组角标越界的异常:ArrayIndexOutOfBoundsException\nfor(int i = 0;i \u0026lt;= arr.length;i++){ // System.out.println(arr[i]); // } 空指针异常:NullPointerException\nString[] arr3 = new String[]{\u0026quot;AA\u0026quot;,\u0026quot;QQ\u0026quot;,\u0026quot;YY\u0026quot;,\u0026quot;XX\u0026quot;,\u0026quot;TT\u0026quot;,\u0026quot;KK\u0026quot;}; // arr3[0] = null; // System.out.println(arr3[0].toString()); 3.4 数组中涉及到的常见算法 选择排序 直接选择排序、堆排序 交换排序 冒泡排序、快速排序 插入排序 直接插入排序、折半插入排序、Shell 排序 归并排序 桶式排序 基数排序 ","permalink":"https://jackywang96.github.io/BlogSite/post/java/java-lesson2/","summary":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 3. 数 组 数组(Array)，是多个相同类型数据按一定顺序排列的集合， 并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。\n数组里的相关概念\nArray name Elements Index length 3.1 一维数组的使用 用以下的方式熟悉一维数组\n一维数组的声明和初始化 如何调用数组的指定位置的元素 如何获取数组的长度 如何遍历数组 数组元素的默认初始化值 3.2 多维数组的使用 对于二维数组的理解，我们可以看成是一维数组array1 又作为另一个一维数组array2 的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。\npublic class ArrayTest2 { public static void main(String[] args) { //1. 二维数组的声明和初始化 int[] arr = new int[]{1,2,3}; // 静态初始化 int[][] arr1 = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; // 动态初始化1 String[][] arr2 = new String[3][2]; // 动态初始化2 String[][] arr3 = new String[3][]; // 错误的情况 // String[][] arr4 = new String[][]; // String[][] arr5 = new String[][4]; // String[][] arr6 = new String[4][3]{{1,2,3},{4,5,6},{7,8,9}}; // 正确的情况： int arr4[][] = new int[][]{{1,2,3},{4,5,12,6},{7,8,9}}; int[] arr5[] = new int[][]{{1,2,3},{4,5,6},{7,8,9}}; int[][] arr6 = {{1,2,3},{4,5,6},{7,8,9}}; //2.","title":"Java Lesson2 Note"},{"content":"Introduction 今天开始我将开始Java基础课程的教授。我会记录我每次备课的note并作为帖子发送至我的blog。\nContent 1. Java是什么样的语言 简单而言，使用JDK 的开发工具完成的java 程序，交给JRE 去运行\n- 面向对象: OOD（Object Oriented Programming）POP（Prodedure Oriented Programming）\n面向对象好在哪：POP小公司人少，所有安排事情是-你去干啥，他去干啥\nOOD: 大公司人多，分成多个部门，按职能分派任务\n三大特性：封装、继承、多态: 封装 用一个method隐藏赋值的过程、把属性变为private。只有外界用method去调用 public, private, default\n继承 inheritance； Child and parent class\n多态 overload\n- 健壮性: 吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如指针、 内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。\n- 跨平台性: 跨平台性：通过Java 语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 原理：只要在需要运行java 应用程序的操作系统上，先安装一个Java 虚拟机 (JVM Java Virtual Machine) 即可。由JVM 来负责Java 程序在该系统中的运行。\nJava 两种核心机制-Java VirtalMachine，Garbage Collection\n2. 基本语法 2.1 Java 中的名称命名规范 Package name: ：多单词组成时所有字母都小写：xxxyyyzzz Class、interface：所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ\n2.2 基本数据类型 变量按照数据类型来分： 基本数据类型：\n整型：byte \\ short \\ int \\ long\n浮点型：float \\ double\n字符型：char\n布尔型：boolean\n引用数据类型：\n类：class\n接口：interface\n数组：array\n2.3 字符串类型：String String 类型变量的使用：\nString 属于引用数据类型 。 声明String 类型变量时，使用一对\u0026quot;\u0026quot; 。 String 可以和8 种基本数据类型变量做运算， 且运算只能是连接运算；+ 运算的结果任然是String 类型。 2.4 强制类型转换 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出, 格外要注意。 通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。\n如：String a = “43”;\ninti= Integer.parseInt(a);\nboolean 类型不可以转换为其它的数据类型。\n2.5 运算符 % 取余 7%5=2\n++ a=2; b=a++; a=2;b=3\n扩展赋值运算符：+=, -=, *=, /=, %=\n逻辑运算符\na||b a\u0026amp;\u0026amp;b\n2.6 顺序结构 public class Test{ int num1 = 12; int num2 = num1 + 2; } // 错误形式： public class Test{ int num2 = num1 + 2; int num1 = 12; } 2.7 判断语句 2.7.1、分支语句：if-else 结构 if(X\u0026gt;=0){ return result } else if(x\u0026lt;0\u0026gt;){ return 1; } else{ return 0; } 2.8. 循环结构 2.8.1 for 循环 // 遍历100 以内的偶数, 获取所有偶数的和, 输出偶数的个数 int sum=0; int count=0; for(int i=1; i\u0026lt;=100; i++){ if(i%2==0){ System.out.println(i); sum += i; count++ } } System.out.println(\u0026ldquo;100 以内的偶数的和：\u0026rdquo; + sum); System.out.println(\u0026quot; 个数为：\u0026quot; + count);\n2.8.2 while 循环 class WhileTest{ public static void main(String[] args){ // 遍历100 以内的所有偶数 int i = 1; while(i \u0026lt;= 100){ if(i % 2 == 0){ System.out.println(i); } i++; } } } 2.8.3 do-while 循环 int i = 0; do { System.out.println(i); i++; } while (i \u0026lt; 5); 2.9. break、continue 的使用 break 语句用于终止某个语句块的执行\n{ ...... break; ...... } continue 的使用 continue 语句：continue 只能使用在循环结构中。\ncontinue 语句用于跳过其所在循环语句块的一次执行，继续下一次 循环。\nreturn return：并非专门用于结束循环的，它的功能是结束一个方法。当一 个方法执行到一个return 语句时，这个方法将被结束。\n与break 和continue 不同的是，return 直接结束整个方法，不管这个 return 处于多少层循环之内。\n课后作业 目标\n需求说明\n基本金和收支明细的记录\n模拟实现一个基于文本界面的《家庭记账软件》。\n主要掌握以下知识点： 变量的定义， 基本数据类型的使用， 循环语句， 分支语句， 方法声明、调用和返回值的接收， 简单的屏幕输出格式控制 模拟实现基于文本界面的《家庭记账软件》。 该软件能够记录家庭收入、支出，并能够打印收支明细表。\n项目采用分级菜单方式。主菜单如下：\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 家庭收支记账软件\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n收支明细 登记收入 登记支出 退 出 请选择(1-4): ","permalink":"https://jackywang96.github.io/BlogSite/post/java/javal-lesson1/","summary":"Introduction 今天开始我将开始Java基础课程的教授。我会记录我每次备课的note并作为帖子发送至我的blog。\nContent 1. Java是什么样的语言 简单而言，使用JDK 的开发工具完成的java 程序，交给JRE 去运行\n- 面向对象: OOD（Object Oriented Programming）POP（Prodedure Oriented Programming）\n面向对象好在哪：POP小公司人少，所有安排事情是-你去干啥，他去干啥\nOOD: 大公司人多，分成多个部门，按职能分派任务\n三大特性：封装、继承、多态: 封装 用一个method隐藏赋值的过程、把属性变为private。只有外界用method去调用 public, private, default\n继承 inheritance； Child and parent class\n多态 overload\n- 健壮性: 吸收了C/C++ 语言的优点，但去掉了其影响程序健壮性的部分（如指针、 内存的申请与释放等），提供了一个相对安全的内存管理和访问机制。\n- 跨平台性: 跨平台性：通过Java 语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere” 原理：只要在需要运行java 应用程序的操作系统上，先安装一个Java 虚拟机 (JVM Java Virtual Machine) 即可。由JVM 来负责Java 程序在该系统中的运行。\nJava 两种核心机制-Java VirtalMachine，Garbage Collection\n2. 基本语法 2.1 Java 中的名称命名规范 Package name: ：多单词组成时所有字母都小写：xxxyyyzzz Class、interface：所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ","title":"Java Lesson1 Note"},{"content":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Spark core module Spark Core: The most basic and core functions of Spark are provided in Spark Core\nSpark SQL: Spark SQL is the component that Spark uses to manipulate structured data. With Spark SQL, users can query data using SQL or the Apache Hive version of the SQL dialect (HQL).\nSpark Streaming: Spark Streaming is a component on the Spark platform that performs stream computing for real-time data, and provides a rich API for processing data streams.\n2. Spark running model Local model:\nAn environment that executes Spark code locally without requiring any other node resources Standalone model:\nSubmit the application to the corresponding cluster for execution, using the cluster mode running on Spark\u0026rsquo;s own nodes, which is what we call the standalone deployment (Standalone) mode.\nOnline monitor: Use the Master resource to monitor the Web UI interface: http://linux1:8080\nYarn model:\nThe Yarn mode can utilize the resources of the Hadoop cluster, and the Spark application is submitted to the YARN cluster. Provides functions such as dynamic resource allocation and job recovery, suitable for large-scale production environments.\nThe Standalone mode is more suitable for small-scale testing and development environments.\nK8S \u0026amp; Mesos model:\nMesos is an open source distributed resource management framework under Apache. It is known as the kernel of a distributed system. It is widely used in Twitter and manages the application deployment on more than 300,000 Twitter servers.\n","permalink":"https://jackywang96.github.io/BlogSite/post/big-data/spark-learning-2/","summary":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Spark core module Spark Core: The most basic and core functions of Spark are provided in Spark Core\nSpark SQL: Spark SQL is the component that Spark uses to manipulate structured data. With Spark SQL, users can query data using SQL or the Apache Hive version of the SQL dialect (HQL).\nSpark Streaming: Spark Streaming is a component on the Spark platform that performs stream computing for real-time data, and provides a rich API for processing data streams.","title":"Big Data Learning Day-2"},{"content":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Data processing tool Spark and Handoop Apache Spark: Apache Spark is an open-source, distributed computing system designed for big data processing and analytics. It offers support for various data processing tasks, including SQL queries, machine learning, and graph processing, through built-in libraries like Spark SQL, MLlib, and GraphX.\nApache Hadoop: Apache Hadoop is an open-source, distributed computing framework for processing and storing large amounts of data on clusters of commodity hardware. The core components of Hadoop are the Hadoop Distributed File System (HDFS) and the MapReduce programming model. HDFS is a distributed file system that provides high-throughput access to application data, while MapReduce is a parallel data processing model that simplifies large-scale data processing across distributed clusters.\n2. Data storage tool As big data involves large volumes of data, it requires specialized data storage systems such as HDFS, Amazon S3, or Google Cloud Storage.\n3. Data visualization and analysis Once the data has been processed, it needs to be analyzed and presented in a meaningful way. There are several tools available for data visualization and analysis, such as Tableau, Power BI, and Apache Superset.\n4. Data governance and security As big data involves sensitive data, it\u0026rsquo;s important to have strong data governance and security measures in place. This includes access control, data masking, and encryption.\n","permalink":"https://jackywang96.github.io/BlogSite/post/big-data/spark-learning-1/","summary":"Introduction After this article, I will record some experience of learning big data.\nContent 1. Data processing tool Spark and Handoop Apache Spark: Apache Spark is an open-source, distributed computing system designed for big data processing and analytics. It offers support for various data processing tasks, including SQL queries, machine learning, and graph processing, through built-in libraries like Spark SQL, MLlib, and GraphX.\nApache Hadoop: Apache Hadoop is an open-source, distributed computing framework for processing and storing large amounts of data on clusters of commodity hardware.","title":"Big Data Learning Day-1"},{"content":"Introduction Tailwind CSS is a CSS styling library that provides us with all the building blocks we need to build custom designs without using custom styles.\nFeature Tailwind will automatically delete all unused CSS when building production files, so its size in the actual production environment is very small, and it is considered to be the CSS style library with the most design sense.\nInstallation //Install Tailwind CSS npm install -D tailwindcss npx tailwindcss init //Add the paths to all of your template files in your tailwind.config.js file. module.exports = { content: [\u0026#34;./src/**/*.{html,js}\u0026#34;], theme: { extend: {}, }, plugins: [], } //Add the Tailwind directives to your CSS @tailwind base; @tailwind components; @tailwind utilities; //Start the Tailwind CLI build process npx tailwindcss -i ./src/input.css -o ./dist/output.css --watch ","permalink":"https://jackywang96.github.io/BlogSite/post/tailwindcss/","summary":"Introduction Tailwind CSS is a CSS styling library that provides us with all the building blocks we need to build custom designs without using custom styles.\nFeature Tailwind will automatically delete all unused CSS when building production files, so its size in the actual production environment is very small, and it is considered to be the CSS style library with the most design sense.\nInstallation //Install Tailwind CSS npm install -D tailwindcss npx tailwindcss init //Add the paths to all of your template files in your tailwind.","title":"TailwindCSS"},{"content":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer. In this case, a third pointer is required at length of nums1. The role of the third pointer is to select where the larger number is placed\nSolution public class MergeSortedArray { public static void merge(int[]nums1, int m, int[]nums2, int n) { //有序数组条件下，设置3个指针，分别放在nums1，nums2和集合数组的末尾 int i=m-1; int j=n-1; int point= nums1.length-1; //判断nums2是否遍历完成 while(j\u0026gt;=0){ //如果nums2中元素小于nums1中的，则把nums1里的元素放到point指向的位置 //之后移动i和point指针 if(i\u0026gt;=0 \u0026amp;\u0026amp; nums1[i]\u0026gt;nums2[j]){ nums1[point]=nums1[i]; i--; point--; } //nums2的元素较大情况直接把nums2中最大元素放置到数组最右端。 //移动j和point指针 else{ nums1[point]=nums2[j]; point--; j--; } } } ","permalink":"https://jackywang96.github.io/BlogSite/post/fast-slow-pointer-floyd-circle-method/fast-slow-pointer/","summary":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer.","title":"Fast,Slow pointer--Floyd circle method"},{"content":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer. In this case, a third pointer is required at length of nums1. The role of the third pointer is to select where the larger number is placed\nSolution public class MergeSortedArray { public static void merge(int[]nums1, int m, int[]nums2, int n) { //有序数组条件下，设置3个指针，分别放在nums1，nums2和集合数组的末尾 int i=m-1; int j=n-1; int point= nums1.length-1; //判断nums2是否遍历完成 while(j\u0026gt;=0){ //如果nums2中元素小于nums1中的，则把nums1里的元素放到point指向的位置 //之后移动i和point指针 if(i\u0026gt;=0 \u0026amp;\u0026amp; nums1[i]\u0026gt;nums2[j]){ nums1[point]=nums1[i]; i--; point--; } //nums2的元素较大情况直接把nums2中最大元素放置到数组最右端。 //移动j和point指针 else{ nums1[point]=nums2[j]; point--; j--; } } } ","permalink":"https://jackywang96.github.io/BlogSite/post/merge-sorted-array/","summary":"Introduction This article is about how to use double pointers to solve problems such as merge array\nProblem details Leetcode 88. Merge Sorted Array Analysis and thought Because it is a sorted array, add pointers at the end of nums1 and nums2 respectively. The values at the positions of the two pointers are compared each time. Copy the larger number to the last bit of nums1. After that, move the pointer.","title":"Merge Sorted Array"},{"content":"SQL experience\nWhen combining tables, the efficiency of simply using the where statement is lower than join, which is equivalent to full join left join (left join): Returns all records including all records in the left table and records with equal join fields in the right table.\nright join (right join): Returns all records including all records in the right table and records with equal join fields in the left table.\nInner join (equivalent connection or inner connection): only returns the rows with the same connection fields in the two tables.\nfull join (full outer connection): Return all records in the left and right tables and records with the same connection fields in the left and right tables.\nThe way to use Null is Where xxxx is null\nUse limit 1, 1 to filter the second and third data that meet the conditions. eg. the second largest, the second highest\n","permalink":"https://jackywang96.github.io/BlogSite/post/sql/","summary":"SQL experience\nWhen combining tables, the efficiency of simply using the where statement is lower than join, which is equivalent to full join left join (left join): Returns all records including all records in the left table and records with equal join fields in the right table.\nright join (right join): Returns all records including all records in the right table and records with equal join fields in the left table.","title":"SQL"},{"content":"Hi, I\u0026rsquo;m Jack 👋 This is my first post. Welcome to my Blog\n","permalink":"https://jackywang96.github.io/BlogSite/post/my-first-post/","summary":"Hi, I\u0026rsquo;m Jack 👋 This is my first post. Welcome to my Blog","title":"My First Post"},{"content":"Hi, I\u0026rsquo;m Jack 👋 👤 Currently Software Development Engineer at Department of Education Victoria.\n📷 Enthusiastic in fitness, photography, travelling, reading \u0026amp; video games.\n📄 Checkout my resume: English / [简体中文]\n✉️ Contact me at JackyWangMel96@gmail.com\n","permalink":"https://jackywang96.github.io/BlogSite/about/","summary":"Hi, I\u0026rsquo;m Jack 👋 👤 Currently Software Development Engineer at Department of Education Victoria.\n📷 Enthusiastic in fitness, photography, travelling, reading \u0026amp; video games.\n📄 Checkout my resume: English / [简体中文]\n✉️ Contact me at JackyWangMel96@gmail.com","title":"About"}]
>>>>>>> 3c407209cde0b172e47a968dd1c97f5025a447b2
