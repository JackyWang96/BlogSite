<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java Lesson4 Note | Jack Wang</title><meta name=keywords content><meta name=description content="Introduction Today will introduce Java&rsquo;s arrays and their applied algorithms
今天将介绍Java的数组及其应用的算法
Content 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。
重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。
说明
1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参
题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i < arr.length;i++){ arr[i] = arr[i] / arr[0]; }"><meta name=author content><link rel=canonical href=https://jackywang96.github.io/BlogSite/post/java/javal-lesson4/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/BlogSite/assets/css/stylesheet.96899f97d8f8189d0ff2f895ef7d104ef2a38fa0104562f554c249c6476eda64.css integrity rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/BlogSite/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jackywang96.github.io/BlogSite/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://jackywang96.github.io/BlogSite/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://jackywang96.github.io/BlogSite/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://jackywang96.github.io/BlogSite/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://jackywang96.github.io/BlogSite/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-132809676-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Java Lesson4 Note"><meta property="og:description" content="Introduction Today will introduce Java&rsquo;s arrays and their applied algorithms
今天将介绍Java的数组及其应用的算法
Content 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。
重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。
说明
1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参
题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i < arr.length;i++){ arr[i] = arr[i] / arr[0]; }"><meta property="og:type" content="article"><meta property="og:url" content="https://jackywang96.github.io/BlogSite/post/java/javal-lesson4/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-04-15T22:54:19+10:00"><meta property="article:modified_time" content="2023-04-15T22:54:19+10:00"><meta property="og:site_name" content="Jack Wang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java Lesson4 Note"><meta name=twitter:description content="Introduction Today will introduce Java&rsquo;s arrays and their applied algorithms
今天将介绍Java的数组及其应用的算法
Content 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。
重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。
说明
1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参
题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i < arr.length;i++){ arr[i] = arr[i] / arr[0]; }"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jackywang96.github.io/BlogSite/post/"},{"@type":"ListItem","position":2,"name":"Java Lesson4 Note","item":"https://jackywang96.github.io/BlogSite/post/java/javal-lesson4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java Lesson4 Note","name":"Java Lesson4 Note","description":"Introduction Today will introduce Java\u0026rsquo;s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。\n重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。\n说明\n1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参\n题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i \u0026lt; arr.length;i++){ arr[i] = arr[i] / arr[0]; }","keywords":[],"articleBody":"Introduction Today will introduce Java’s arrays and their applied algorithms\n今天将介绍Java的数组及其应用的算法\nContent 4. 4 方法的重载 重载的概念 在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数 类型不同即可。\n重载的特点： 与返回值类型无关，只看参数列表，且参数列表必须不同。 参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。\n说明\n1.声明格式： 方法名 参数的类型名 参数名 2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个 3.可变 个数形参的方法与同名的方法之间，彼此构成重载 4.可变 参数方法的使用与方法参数部分使用数组是一致的 5.方法 的参数部分有可变形参，需要放在形参声明 的 最后 6.在 一个方法的形参位置，最多只能声明一个可变个数形参\n题目 定义 一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432}; 让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的 新值。遍历新的数组。 答案 // 错误写法 for(int i= 0 i \u003c arr.length;i++){ arr[i] = arr[i] / arr[0]; }\n4.5 ：递归方法 递归方法：一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执 行无须循环控制。\n递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死 循环。\nexample //计算 1-100 之间所有自然数的和\npublic int sum(int num){ if(num == 1){ return 1; } else{ return num + sum(num 1); } } 4.6 ：面向对象 特征之一：封装和隐藏 为什么需要封装？封装的作用和含义？ -我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内 部的结构吗？有必要碰电动机吗？ 我们 程序设计追求 “高内聚，低耦合”。\n高内聚 ：类 的内部数据 操作细节自己完成，不允许外部干涉；\n低耦合 仅对外暴露 少量的 方法 用于 使用 。\n4.7 ：构造器重载 构造器一般用于创建对象的同时初始化对象 构造器的重载帮助创建对象更灵活。适合创建不同的对象 构造器重载，参数列表 必须 不同 4.8： 关键字 4.8.1： 关键字this 4.8.2： 关键字static 4.8.3： 关键字pacakge package 语句作为 Java 源文件的第一条语句，指明该文件中定义的类所在 的包。 若缺省该语句，则指定为无名包 。它的格式为： package 顶层包名.子包名\n举例 //pack1\\pack2\\PackageTest.java package pack1.pack2;\n包的作用\n包帮助管理大型软件 系统 将功能 相近的类划分到同一个包中 。 比如 MVC 的设计模式\n包可以包含类和 子包 划分项目 层次 便于管理\n控制访问权限\n4.8.4： 关键字import 为使用定义在不同包中的 Java 类，需用 import 语句来引入 指定包层次下 所需要的类 或全部类 。 import 语句告诉编译器到哪里去寻找类。\n","wordCount":"178","inLanguage":"en","datePublished":"2023-04-15T22:54:19+10:00","dateModified":"2023-04-15T22:54:19+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jackywang96.github.io/BlogSite/post/java/javal-lesson4/"},"publisher":{"@type":"Organization","name":"Jack Wang","logo":{"@type":"ImageObject","url":"https://jackywang96.github.io/BlogSite/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jackywang96.github.io/BlogSite/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jackywang96.github.io/BlogSite/archives/ title=Posts><span>Posts</span></a></li><li><a href=https://jackywang96.github.io/BlogSite/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jackywang96.github.io/BlogSite/>Home</a>&nbsp;»&nbsp;<a href=https://jackywang96.github.io/BlogSite/post/>Posts</a></div><h1 class=post-title>Java Lesson4 Note</h1><div class=post-meta><span title='2023-04-15 22:54:19 +1000 AEST'>April 15, 2023</span>&nbsp;·&nbsp;1 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#content aria-label=Content>Content</a><ul><li><a href=#4-4-%e6%96%b9%e6%b3%95%e7%9a%84%e9%87%8d%e8%bd%bd aria-label="4. 4 方法的重载">4. 4 方法的重载</a></li><li><a href=#45-%e9%80%92%e5%bd%92%e6%96%b9%e6%b3%95 aria-label="4.5 ：递归方法">4.5 ：递归方法</a></li><li><a href=#46-%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1-%e7%89%b9%e5%be%81%e4%b9%8b%e4%b8%80%e5%b0%81%e8%a3%85%e5%92%8c%e9%9a%90%e8%97%8f aria-label="4.6 ：面向对象 特征之一：封装和隐藏">4.6 ：面向对象 特征之一：封装和隐藏</a></li><li><a href=#47-%e6%9e%84%e9%80%a0%e5%99%a8%e9%87%8d%e8%bd%bd aria-label="4.7 ：构造器重载">4.7 ：构造器重载</a></li><li><a href=#48-%e5%85%b3%e9%94%ae%e5%ad%97 aria-label="4.8： 关键字">4.8： 关键字</a><ul><li><a href=#481-%e5%85%b3%e9%94%ae%e5%ad%97this aria-label="4.8.1： 关键字this">4.8.1： 关键字this</a></li><li><a href=#482-%e5%85%b3%e9%94%ae%e5%ad%97static aria-label="4.8.2： 关键字static">4.8.2： 关键字static</a></li><li><a href=#483-%e5%85%b3%e9%94%ae%e5%ad%97pacakge aria-label="4.8.3： 关键字pacakge">4.8.3： 关键字pacakge</a></li><li><a href=#484-%e5%85%b3%e9%94%ae%e5%ad%97import aria-label="4.8.4： 关键字import">4.8.4： 关键字import</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>Today will introduce Java&rsquo;s arrays and their applied algorithms</p><p>今天将介绍Java的数组及其应用的算法</p><h1 id=content>Content<a hidden class=anchor aria-hidden=true href=#content>#</a></h1><h2 id=4-4-方法的重载>4. 4 方法的重载<a hidden class=anchor aria-hidden=true href=#4-4-方法的重载>#</a></h2><ol><li><p>重载的概念
在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数
类型不同即可。</p></li><li><p>重载的特点：
与返回值类型无关，只看参数列表，且参数列表必须不同。
参数个数或参数类型 。调用时， 根据方法参数列表的不同来区别。</p></li><li><p>说明</p></li></ol><p>1.声明格式： 方法名 参数的类型名 参数名
2.可变 参数：方法参数部分指定类型的参数个数是可变 多 个： 0 个， 1 个或多个
3.可变 个数形参的方法与同名的方法之间，彼此构成重载
4.可变 参数方法的使用与方法参数部分使用数组是一致的
5.方法 的参数部分有可变形参，需要放在形参声明 的 最后
6.在 一个方法的形参位置，最多只能声明一个可变个数形参</p><ol start=4><li>题目
定义
一个 int 型的数组： int[] arr = new int[]{12,3,3,34,56,77,432};
让数组的每个位置上的值去除以首位置的元素，得到的结果，作为该位置上的
新值。遍历新的数组。</li></ol><p>答案
//
错误写法
for(int
i= 0 i &lt; arr.length;i++){
arr[i] = arr[i] /
arr[0];
}</p><h2 id=45-递归方法>4.5 ：递归方法<a hidden class=anchor aria-hidden=true href=#45-递归方法>#</a></h2><ol><li>递归方法：一个方法体内调用它自身。</li></ol><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执
行无须循环控制。</p><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死
循环。</p><ol start=2><li>example</li></ol><p>//计算 1-100 之间所有自然数的和</p><pre><code>    public int sum(int num){
        if(num == 1){
        return 1;
        }
        else{
        return num + sum(num
        1);
        }
        }
</code></pre><h2 id=46-面向对象-特征之一封装和隐藏>4.6 ：面向对象 特征之一：封装和隐藏<a hidden class=anchor aria-hidden=true href=#46-面向对象-特征之一封装和隐藏>#</a></h2><ol><li>为什么需要封装？封装的作用和含义？
-我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内
部的结构吗？有必要碰电动机吗？</li></ol><p>我们 程序设计追求 “高内聚，低耦合”。</p><p>高内聚 ：类 的内部数据 操作细节自己完成，不允许外部干涉；</p><p>低耦合 仅对外暴露 少量的 方法 用于 使用 。</p><h2 id=47-构造器重载>4.7 ：构造器重载<a hidden class=anchor aria-hidden=true href=#47-构造器重载>#</a></h2><ol><li>构造器一般用于创建对象的同时初始化对象</li><li>构造器的重载帮助创建对象更灵活。适合创建不同的对象</li><li>构造器重载，参数列表 必须 不同</li></ol><h2 id=48-关键字>4.8： 关键字<a hidden class=anchor aria-hidden=true href=#48-关键字>#</a></h2><h3 id=481-关键字this>4.8.1： 关键字this<a hidden class=anchor aria-hidden=true href=#481-关键字this>#</a></h3><h3 id=482-关键字static>4.8.2： 关键字static<a hidden class=anchor aria-hidden=true href=#482-关键字static>#</a></h3><h3 id=483-关键字pacakge>4.8.3： 关键字pacakge<a hidden class=anchor aria-hidden=true href=#483-关键字pacakge>#</a></h3><p>package 语句作为 Java 源文件的第一条语句，指明该文件中定义的类所在
的包。 若缺省该语句，则指定为无名包 。它的格式为：
package 顶层包名.子包名</p><ol><li><p>举例
//pack1\pack2\PackageTest.java
package pack1.pack2;</p></li><li><p>包的作用</p><p>包帮助管理大型软件 系统 将功能 相近的类划分到同一个包中 。 比如 MVC 的设计模式</p><p>包可以包含类和 子包 划分项目 层次 便于管理</p><p>控制访问权限</p></li></ol><h3 id=484-关键字import>4.8.4： 关键字import<a hidden class=anchor aria-hidden=true href=#484-关键字import>#</a></h3><p>为使用定义在不同包中的 Java 类，需用 import 语句来引入 指定包层次下 所需要的类
或全部类 。 import 语句告诉编译器到哪里去寻找类。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://jackywang96.github.io/BlogSite/post/java/java-lesson3/><span class=title>Next »</span><br><span>Java Lesson3 Note</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jackywang96.github.io/BlogSite/>Jack Wang</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>